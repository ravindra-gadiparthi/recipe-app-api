from django.contrib.auth import get_user_model, authenticatefrom rest_framework import serializersfrom django.utils.translation import ugettext_lazy as _class UserSerializer(serializers.ModelSerializer):    """Serializer for User Object"""    class Meta:        model = get_user_model()        fields = (            'name',            'email',            'password'        )        extra_kwargs = {            'password': {                'write_only': True,                'min_length': 5            }        }    def create(self, validated_data):        """create user with encrypted password"""        return get_user_model().objects.create_user(**validated_data)    def update(self, instance, validated_data):        password = validated_data.pop('password', None)        super().update(instance, validated_data)        if password:            instance.set_password(password)        instance.save()        return instanceclass AuthTokenSerializer(serializers.Serializer):    email = serializers.CharField(label=_("email"))    password = serializers.CharField(        label=_("Password"),        style={'input_type': 'password'},        trim_whitespace=False    )    def validate(self, attrs):        username = attrs.get('email')        password = attrs.get('password')        if username and password:            user = authenticate(request=self.context.get('request'),                                username=username, password=password)            # The authenticate call simply returns None for is_active=False            # users. (Assuming the default ModelBackend authentication            # backend.)            if not user:                msg = _('Unable to log with provided credentials.')                raise serializers.ValidationError(msg, code='authorization')        else:            msg = _('Must include "email" and "password".')            raise serializers.ValidationError(msg, code='authorization')        attrs['user'] = user        return attrs